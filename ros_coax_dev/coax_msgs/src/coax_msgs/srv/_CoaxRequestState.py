"""autogenerated by genmsg_py from CoaxRequestStateRequest.msg. Do not edit."""
import roslib.message
import struct


class CoaxRequestStateRequest(roslib.message.Message):
  _md5sum = "348fe2cc71120f4496a69790cdcccdf4"
  _type = "coax_msgs/CoaxRequestStateRequest"
  _has_header = False #flag to mark the presence of a Header object
  _full_text = """uint32 contents

"""
  __slots__ = ['contents']
  _slot_types = ['uint32']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.
    
    The available fields are:
       contents
    
    @param args: complete set of field values, in .msg order
    @param kwds: use keyword arguments corresponding to message field names
    to set specific fields. 
    """
    if args or kwds:
      super(CoaxRequestStateRequest, self).__init__(*args, **kwds)
      #message fields cannot be None, assign default values for those that are
      if self.contents is None:
        self.contents = 0
    else:
      self.contents = 0

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    @param buff: buffer
    @type  buff: StringIO
    """
    try:
      buff.write(_struct_I.pack(self.contents))
    except struct.error, se: self._check_types(se)
    except TypeError, te: self._check_types(te)

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    @param str: byte array of serialized message
    @type  str: str
    """
    try:
      end = 0
      start = end
      end += 4
      (self.contents,) = _struct_I.unpack(str[start:end])
      return self
    except struct.error, e:
      raise roslib.message.DeserializationError(e) #most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    @param buff: buffer
    @type  buff: StringIO
    @param numpy: numpy python module
    @type  numpy module
    """
    try:
      buff.write(_struct_I.pack(self.contents))
    except struct.error, se: self._check_types(se)
    except TypeError, te: self._check_types(te)

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    @param str: byte array of serialized message
    @type  str: str
    @param numpy: numpy python module
    @type  numpy: module
    """
    try:
      end = 0
      start = end
      end += 4
      (self.contents,) = _struct_I.unpack(str[start:end])
      return self
    except struct.error, e:
      raise roslib.message.DeserializationError(e) #most likely buffer underfill

_struct_I = roslib.message.struct_I
"""autogenerated by genmsg_py from CoaxRequestStateResponse.msg. Do not edit."""
import roslib.message
import struct

import roslib.msg
import coax_msgs.msg

class CoaxRequestStateResponse(roslib.message.Message):
  _md5sum = "a2aab5ad3b91c710747a48adb6c7c7f2"
  _type = "coax_msgs/CoaxRequestStateResponse"
  _has_header = False #flag to mark the presence of a Header object
  _full_text = """CoaxState state



================================================================================
MSG: coax_msgs/CoaxState
Header header
# Error status set by the helicopter */
uint8 errorFlags
# 
#	 Affected content in this data structure (
#    Use AND with the SBS_... flags above to check the content  
#    e.g: if (state.content & SBS_RPY) {  
#   			compute_odo(state.roll,state.pitch,state.yaw)  
#   		}  
#    This content should correspond to what has been configured in  
#    sbConfigureComm or requested in sbRequestState  *#
uint32 content
# timestamp of the last update, in ms since the initialisation of the
#  helicopter. *#
uint32 timeStamp
# current control timeout (for sending command in SB_NAV_CTRLLED mode) */
uint16 controlTimeout
# current comm timeout, to bring the helicopter back to safety is
#  communication is not maintained. *#
uint16 watchdogTimeout
# Various bit field to represent the system configuration*/
CoaxModes mode

# Current helicopter attitude */
float32 roll
float32 pitch
float32 yaw
# GYRO data */
float32[3] gyro
# Accelerometer data */
float32[3] accel
# Magnetometer data */
float32[3] magneto
# Temperature measured by IMU */
float32 imutemp
# Range measurement in the vertical direction */
float32 zrange
# Filtered altitude, as used by the altitude control in POS mode */
float32 zfiltered
# Output of pressure sensor */
float32 pressure
# Range measurements in the horizontal plane. Sensor placement is
#  platform dependent *#
float32[4] hranges
# Distance to closest obstacle (if implemented) */
float32 xrel
float32 yrel
# Battery voltage */
float32 battery
# Output of the remote control channel, normalised to [-1,1] */
float32[8] rcChannel

# symbols below may be suppressed in future version of the library */

# Output of attitude control (semantic unclear) */
float32[3] o_attitude
# Output of altitude control, i.e. thrust to keep the helicopter affloat32  */
float32 o_altitude
# Output of take-off/landing control (semantic unclear) */
float32 o_tol
# ??? (semantic unclear) */
float32[2] o_xy
# ??? (semantic unclear) */
float32[2] o_oavoid


================================================================================
MSG: roslib/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data 
# in a particular coordinate frame.
# 
# sequence ID: consecutively increasing ID 
uint32 seq
#Two-integer timestamp that is expressed as:
# * stamp.secs: seconds (stamp_secs) since epoch
# * stamp.nsecs: nanoseconds since stamp_secs
# time-handling sugar is provided by the client library
time stamp
#Frame this data is associated with
# 0: no frame
# 1: global frame
string frame_id

================================================================================
MSG: coax_msgs/CoaxModes
# Navigation mode: SB_NAV_... */
uint8 navigation
# Communication mode: SB_COM_... */
uint8 communication
# Obstacle avoidance mode: or of SB_OA_... */
uint8 oavoid
# Control mode for roll axis: SB_CTRL_... */
uint8 rollAxis
# Control mode for pitch axis: SB_CTRL_... */
uint8 pitchAxis
# Control mode for yaw axis: SB_CTRL_... */
uint8 yawAxis
# Control mode for altitude axis: SB_CTRL_... */
uint8 altAxis

"""
  __slots__ = ['state']
  _slot_types = ['coax_msgs/CoaxState']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.
    
    The available fields are:
       state
    
    @param args: complete set of field values, in .msg order
    @param kwds: use keyword arguments corresponding to message field names
    to set specific fields. 
    """
    if args or kwds:
      super(CoaxRequestStateResponse, self).__init__(*args, **kwds)
      #message fields cannot be None, assign default values for those that are
      if self.state is None:
        self.state = coax_msgs.msg.CoaxState()
    else:
      self.state = coax_msgs.msg.CoaxState()

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    @param buff: buffer
    @type  buff: StringIO
    """
    try:
      _x = self
      buff.write(_struct_3I.pack(_x.state.header.seq, _x.state.header.stamp.secs, _x.state.header.stamp.nsecs))
      _x = self.state.header.frame_id
      length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_struct_B2I2H7B3f.pack(_x.state.errorFlags, _x.state.content, _x.state.timeStamp, _x.state.controlTimeout, _x.state.watchdogTimeout, _x.state.mode.navigation, _x.state.mode.communication, _x.state.mode.oavoid, _x.state.mode.rollAxis, _x.state.mode.pitchAxis, _x.state.mode.yawAxis, _x.state.mode.altAxis, _x.state.roll, _x.state.pitch, _x.state.yaw))
      buff.write(_struct_3f.pack(*self.state.gyro))
      buff.write(_struct_3f.pack(*self.state.accel))
      buff.write(_struct_3f.pack(*self.state.magneto))
      _x = self
      buff.write(_struct_4f.pack(_x.state.imutemp, _x.state.zrange, _x.state.zfiltered, _x.state.pressure))
      buff.write(_struct_4f.pack(*self.state.hranges))
      _x = self
      buff.write(_struct_3f.pack(_x.state.xrel, _x.state.yrel, _x.state.battery))
      buff.write(_struct_8f.pack(*self.state.rcChannel))
      buff.write(_struct_3f.pack(*self.state.o_attitude))
      _x = self
      buff.write(_struct_2f.pack(_x.state.o_altitude, _x.state.o_tol))
      buff.write(_struct_2f.pack(*self.state.o_xy))
      buff.write(_struct_2f.pack(*self.state.o_oavoid))
    except struct.error, se: self._check_types(se)
    except TypeError, te: self._check_types(te)

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    @param str: byte array of serialized message
    @type  str: str
    """
    try:
      if self.state is None:
        self.state = coax_msgs.msg.CoaxState()
      end = 0
      _x = self
      start = end
      end += 12
      (_x.state.header.seq, _x.state.header.stamp.secs, _x.state.header.stamp.nsecs,) = _struct_3I.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      self.state.header.frame_id = str[start:end]
      _x = self
      start = end
      end += 32
      (_x.state.errorFlags, _x.state.content, _x.state.timeStamp, _x.state.controlTimeout, _x.state.watchdogTimeout, _x.state.mode.navigation, _x.state.mode.communication, _x.state.mode.oavoid, _x.state.mode.rollAxis, _x.state.mode.pitchAxis, _x.state.mode.yawAxis, _x.state.mode.altAxis, _x.state.roll, _x.state.pitch, _x.state.yaw,) = _struct_B2I2H7B3f.unpack(str[start:end])
      start = end
      end += 12
      self.state.gyro = _struct_3f.unpack(str[start:end])
      start = end
      end += 12
      self.state.accel = _struct_3f.unpack(str[start:end])
      start = end
      end += 12
      self.state.magneto = _struct_3f.unpack(str[start:end])
      _x = self
      start = end
      end += 16
      (_x.state.imutemp, _x.state.zrange, _x.state.zfiltered, _x.state.pressure,) = _struct_4f.unpack(str[start:end])
      start = end
      end += 16
      self.state.hranges = _struct_4f.unpack(str[start:end])
      _x = self
      start = end
      end += 12
      (_x.state.xrel, _x.state.yrel, _x.state.battery,) = _struct_3f.unpack(str[start:end])
      start = end
      end += 32
      self.state.rcChannel = _struct_8f.unpack(str[start:end])
      start = end
      end += 12
      self.state.o_attitude = _struct_3f.unpack(str[start:end])
      _x = self
      start = end
      end += 8
      (_x.state.o_altitude, _x.state.o_tol,) = _struct_2f.unpack(str[start:end])
      start = end
      end += 8
      self.state.o_xy = _struct_2f.unpack(str[start:end])
      start = end
      end += 8
      self.state.o_oavoid = _struct_2f.unpack(str[start:end])
      return self
    except struct.error, e:
      raise roslib.message.DeserializationError(e) #most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    @param buff: buffer
    @type  buff: StringIO
    @param numpy: numpy python module
    @type  numpy module
    """
    try:
      _x = self
      buff.write(_struct_3I.pack(_x.state.header.seq, _x.state.header.stamp.secs, _x.state.header.stamp.nsecs))
      _x = self.state.header.frame_id
      length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_struct_B2I2H7B3f.pack(_x.state.errorFlags, _x.state.content, _x.state.timeStamp, _x.state.controlTimeout, _x.state.watchdogTimeout, _x.state.mode.navigation, _x.state.mode.communication, _x.state.mode.oavoid, _x.state.mode.rollAxis, _x.state.mode.pitchAxis, _x.state.mode.yawAxis, _x.state.mode.altAxis, _x.state.roll, _x.state.pitch, _x.state.yaw))
      buff.write(self.state.gyro.tostring())
      buff.write(self.state.accel.tostring())
      buff.write(self.state.magneto.tostring())
      _x = self
      buff.write(_struct_4f.pack(_x.state.imutemp, _x.state.zrange, _x.state.zfiltered, _x.state.pressure))
      buff.write(self.state.hranges.tostring())
      _x = self
      buff.write(_struct_3f.pack(_x.state.xrel, _x.state.yrel, _x.state.battery))
      buff.write(self.state.rcChannel.tostring())
      buff.write(self.state.o_attitude.tostring())
      _x = self
      buff.write(_struct_2f.pack(_x.state.o_altitude, _x.state.o_tol))
      buff.write(self.state.o_xy.tostring())
      buff.write(self.state.o_oavoid.tostring())
    except struct.error, se: self._check_types(se)
    except TypeError, te: self._check_types(te)

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    @param str: byte array of serialized message
    @type  str: str
    @param numpy: numpy python module
    @type  numpy: module
    """
    try:
      if self.state is None:
        self.state = coax_msgs.msg.CoaxState()
      end = 0
      _x = self
      start = end
      end += 12
      (_x.state.header.seq, _x.state.header.stamp.secs, _x.state.header.stamp.nsecs,) = _struct_3I.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      self.state.header.frame_id = str[start:end]
      _x = self
      start = end
      end += 32
      (_x.state.errorFlags, _x.state.content, _x.state.timeStamp, _x.state.controlTimeout, _x.state.watchdogTimeout, _x.state.mode.navigation, _x.state.mode.communication, _x.state.mode.oavoid, _x.state.mode.rollAxis, _x.state.mode.pitchAxis, _x.state.mode.yawAxis, _x.state.mode.altAxis, _x.state.roll, _x.state.pitch, _x.state.yaw,) = _struct_B2I2H7B3f.unpack(str[start:end])
      start = end
      end += 12
      self.state.gyro = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=3)
      start = end
      end += 12
      self.state.accel = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=3)
      start = end
      end += 12
      self.state.magneto = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=3)
      _x = self
      start = end
      end += 16
      (_x.state.imutemp, _x.state.zrange, _x.state.zfiltered, _x.state.pressure,) = _struct_4f.unpack(str[start:end])
      start = end
      end += 16
      self.state.hranges = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=4)
      _x = self
      start = end
      end += 12
      (_x.state.xrel, _x.state.yrel, _x.state.battery,) = _struct_3f.unpack(str[start:end])
      start = end
      end += 32
      self.state.rcChannel = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=8)
      start = end
      end += 12
      self.state.o_attitude = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=3)
      _x = self
      start = end
      end += 8
      (_x.state.o_altitude, _x.state.o_tol,) = _struct_2f.unpack(str[start:end])
      start = end
      end += 8
      self.state.o_xy = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=2)
      start = end
      end += 8
      self.state.o_oavoid = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=2)
      return self
    except struct.error, e:
      raise roslib.message.DeserializationError(e) #most likely buffer underfill

_struct_I = roslib.message.struct_I
_struct_B2I2H7B3f = struct.Struct("<B2I2H7B3f")
_struct_8f = struct.Struct("<8f")
_struct_2f = struct.Struct("<2f")
_struct_3I = struct.Struct("<3I")
_struct_4f = struct.Struct("<4f")
_struct_3f = struct.Struct("<3f")
class CoaxRequestState(roslib.message.ServiceDefinition):
  _type          = 'coax_msgs/CoaxRequestState'
  _md5sum = 'c48ce683e12ad9d0e530beb095838004'
  _request_class  = CoaxRequestStateRequest
  _response_class = CoaxRequestStateResponse
