/* Auto-generated by genmsg_cpp for file /home/aaron/ros_pkgs/siue_coax_dev/ros_coax_dev/coax_msgs/msg/CoaxConstants.msg */
#ifndef COAX_MSGS_MESSAGE_COAXCONSTANTS_H
#define COAX_MSGS_MESSAGE_COAXCONSTANTS_H
#include <string>
#include <vector>
#include <ostream>
#include "ros/serialization.h"
#include "ros/builtin_message_traits.h"
#include "ros/message_operations.h"
#include "ros/message.h"
#include "ros/time.h"


namespace coax_msgs
{
template <class ContainerAllocator>
struct CoaxConstants_ : public ros::Message
{
  typedef CoaxConstants_<ContainerAllocator> Type;

  CoaxConstants_()
  {
  }

  CoaxConstants_(const ContainerAllocator& _alloc)
  {
  }

  enum { SB_OA_NONE = 0 };
  enum { SB_OA_HORIZONTAL = 1 };
  enum { SB_OA_VERTICAL = 2 };
  enum { SB_COM_ONREQUEST = 0 };
  enum { SB_COM_CONTINUOUS = 1 };
  enum { SB_CTRL_NONE = 0 };
  enum { SB_CTRL_POS = 1 };
  enum { SB_CTRL_REL = 2 };
  enum { SB_CTRL_VEL = 3 };
  enum { SB_CTRL_FORCE = 4 };
  enum { SB_CTRL_MANUAL = 8 };
  enum { SB_RAWPROFILE_STEP = 0 };
  enum { SB_RAWPROFILE_RAMP = 1 };
  enum { SB_NAV_STOP = 0 };
  enum { SB_NAV_IDLE = 1 };
  enum { SB_NAV_TAKEOFF = 2 };
  enum { SB_NAV_LAND = 3 };
  enum { SB_NAV_HOVER = 4 };
  enum { SB_NAV_CTRLLED = 5 };
  enum { SB_NAV_SINK = 6 };
  enum { SB_NAV_RAW = 7 };
  enum { SB_NAV_MANUAL = 8 };
  enum { SB_REPLY_OK = 0 };
  enum { SB_REPLY_INVALID_NAVMODE = 253 };
  enum { SB_REPLY_UNKNOWN = 254 };
  enum { SB_REPLY_ERROR = 255 };
  enum { SB_REPLY_DECODE_FAILURE = 252 };
  enum { SB_REPLY_BUSY = 251 };
  enum { SB_REPLY_TOO_EARLY = 250 };
  enum { SB_RANGE_FRONT = 0 };
  enum { SB_RANGE_LEFT = 1 };
  enum { SB_RANGE_RIGHT = 2 };
  enum { SB_RANGE_BACK = 3 };
  enum { SB_TRIM_FROM_RC = 0 };
  enum { SB_TRIM_SOFTWARE = 1 };
  enum { SB_RC_THROTTLE = 0 };
  enum { SB_RC_THROTTLE_TRIM = 1 };
  enum { SB_RC_YAW = 2 };
  enum { SB_RC_YAW_TRIM = 3 };
  enum { SB_RC_ROLL = 4 };
  enum { SB_RC_ROLL_TRIM = 5 };
  enum { SB_RC_PITCH = 6 };
  enum { SB_RC_PITCH_TRIM = 7 };
  enum { DEBUG_CHANNEL_NONE = -1 };
  enum { DEBUG_CHANNEL_GUMSTIX = 0 };
  enum { DEBUG_CHANNEL_BLUETOOTH = 1 };
  enum { SBS_MODES = 1 };
  enum { SBS_TIMESTAMP = 2 };
  enum { SBS_RPY = 4 };
  enum { SBS_GYRO = 8 };
  enum { SBS_ACCEL = 16 };
  enum { SBS_MAGNETO = 32 };
  enum { SBS_IMUTEMP = 64 };
  enum { SBS_ALTITUDE = 128 };
  enum { SBS_PRESSURE = 256 };
  enum { SBS_HRANGES = 512 };
  enum { SBS_XY_REL = 1024 };
  enum { SBS_BATTERY = 2048 };
  enum { SBS_TIMEOUT = 4096 };
  enum { SBS_O_ATTITUDE = 8192 };
  enum { SBS_O_ALTITUDE = 16384 };
  enum { SBS_O_TOL = 32768 };
  enum { SBS_O_XY = 65536 };
  enum { SBS_O_OAVOID = 131072 };
  enum { SBS_CHANNELS = 262144 };
  enum { SBS_ALL = 16777215 };
  enum { SBS_IMU_ALL = 124 };
  enum { SBS_RANGES_ALL = 640 };
  enum { SBS_ALTITUDE_ALL = 384 };
  enum { SBS_OUTPUT_ALL = 253952 };

private:
  static const char* __s_getDataType_() { return "coax_msgs/CoaxConstants"; }
public:
  ROSCPP_DEPRECATED static const std::string __s_getDataType() { return __s_getDataType_(); }

  ROSCPP_DEPRECATED const std::string __getDataType() const { return __s_getDataType_(); }

private:
  static const char* __s_getMD5Sum_() { return "c6f600e6dca743e84638da373a8ff5be"; }
public:
  ROSCPP_DEPRECATED static const std::string __s_getMD5Sum() { return __s_getMD5Sum_(); }

  ROSCPP_DEPRECATED const std::string __getMD5Sum() const { return __s_getMD5Sum_(); }

private:
  static const char* __s_getMessageDefinition_() { return "\n\
#No obstacle avoidance \n\
uint8 SB_OA_NONE=0\n\
#Horizontal obstacle avoidance \n\
uint8 SB_OA_HORIZONTAL=1\n\
#Vertical obstacle avoidance \n\
uint8 SB_OA_VERTICAL=2\n\
\n\
#Communication on request only \n\
uint8 SB_COM_ONREQUEST=0\n\
#Continuous communication \n\
uint8 SB_COM_CONTINUOUS=1\n\
\n\
#No control \n\
uint16 SB_CTRL_NONE=0\n\
#Position control \n\
uint16 SB_CTRL_POS=1\n\
#Relative set point control (wrt range for instance) \n\
uint16 SB_CTRL_REL=2\n\
#Velocity control \n\
uint16 SB_CTRL_VEL=3\n\
#Acceleration/Force control, currently only used for thrust \n\
uint16 SB_CTRL_FORCE=4\n\
#Manual control \n\
uint16 SB_CTRL_MANUAL=8\n\
\n\
#Step velocity profile for servos in raw mode \n\
uint8 SB_RAWPROFILE_STEP=0\n\
#Ramp velocity profile for servos in raw mode \n\
uint8 SB_RAWPROFILE_RAMP=1\n\
\n\
#Navigation mode: STOP \n\
uint8 SB_NAV_STOP=0\n\
#Navigation mode: IDLE \n\
uint8 SB_NAV_IDLE=1\n\
#Navigation mode: TAKEOFF \n\
uint8 SB_NAV_TAKEOFF=2\n\
#Navigation mode: LAND \n\
uint8 SB_NAV_LAND=3\n\
#Navigation mode: HOVER \n\
uint8 SB_NAV_HOVER=4\n\
#Navigation mode: CTRLLED \n\
uint8 SB_NAV_CTRLLED=5\n\
#Navigation mode: SINK \n\
uint8 SB_NAV_SINK=6\n\
#Navigation mode: RAW \n\
uint8 SB_NAV_RAW=7\n\
#Navigation mode: MANUAL (unused) \n\
uint8 SB_NAV_MANUAL=8\n\
\n\
#Error code in acknowledgement message: no error \n\
uint8 SB_REPLY_OK=   00\n\
#Error code in acknowledgement message: invalid navigation mode \n\
uint8 SB_REPLY_INVALID_NAVMODE=253\n\
#Error code in acknowledgement message: unknown message id or request \n\
uint8 SB_REPLY_UNKNOWN=254\n\
#Error code in acknowledgement message: some error \n\
uint8 SB_REPLY_ERROR=255\n\
#Error code in acknowledgement message: could not decode message \n\
uint8 SB_REPLY_DECODE_FAILURE=252\n\
#Error code in acknowledgement message: request not accepted because system\n\
#  is busy with another connection\n\
uint8 SB_REPLY_BUSY=251\n\
#Error code in acknowledgement message: too early to do this request \n\
uint8 SB_REPLY_TOO_EARLY=250\n\
\n\
#Identification of the range measurement \n\
uint32 SB_RANGE_FRONT=0\n\
uint32 SB_RANGE_LEFT=1\n\
uint32 SB_RANGE_RIGHT=2\n\
uint32 SB_RANGE_BACK=3\n\
\n\
#Id of trim modes \n\
uint32 SB_TRIM_FROM_RC=0\n\
uint32 SB_TRIM_SOFTWARE=1\n\
\n\
#If for RC channels \n\
uint32 SB_RC_THROTTLE=0\n\
uint32 SB_RC_THROTTLE_TRIM=1\n\
uint32 SB_RC_YAW=2\n\
uint32 SB_RC_YAW_TRIM=3\n\
uint32 SB_RC_ROLL=4\n\
uint32 SB_RC_ROLL_TRIM=5\n\
uint32 SB_RC_PITCH=6\n\
uint32 SB_RC_PITCH_TRIM=7\n\
\n\
int32 DEBUG_CHANNEL_NONE=-1\n\
int32 DEBUG_CHANNEL_GUMSTIX=0\n\
int32 DEBUG_CHANNEL_BLUETOOTH=1\n\
\n\
#System mode (nav, comm, ...) \n\
uint32 SBS_MODES=1\n\
#System timestamp \n\
uint32 SBS_TIMESTAMP=2\n\
#Roll, pitch, yaw from IMU \n\
uint32 SBS_RPY=4\n\
#Roll, pitch, yaw rate from IMU \n\
uint32 SBS_GYRO=8\n\
#Acceleration from IMU \n\
uint32 SBS_ACCEL=16\n\
#Magnetic field vector from IMU \n\
uint32 SBS_MAGNETO=32\n\
#Temperature from IMU \n\
uint32 SBS_IMUTEMP=64\n\
#Range to the floor, and filtered altitude \n\
uint32 SBS_ALTITUDE=128\n\
#Altitude from pressure sensor \n\
uint32 SBS_PRESSURE=256\n\
#Horizontal ranges to obstacles \n\
uint32 SBS_HRANGES=512\n\
#Distance to closest object \n\
uint32 SBS_XY_REL=1024\n\
#Battery status \n\
uint32 SBS_BATTERY=2048\n\
#Timeout currently used \n\
uint32 SBS_TIMEOUT=4096\n\
#Output of Attitude control \n\
uint32 SBS_O_ATTITUDE=8192\n\
#Output of Altitude control \n\
uint32 SBS_O_ALTITUDE=16384\n\
#Output of TakeOff/Landing control \n\
uint32 SBS_O_TOL=32768\n\
#Output of XY control \n\
uint32 SBS_O_XY=65536\n\
#Output of Obstacle avoidance control \n\
uint32 SBS_O_OAVOID=131072\n\
\n\
#Output of Obstacle avoidance control \n\
uint32 SBS_CHANNELS=262144\n\
\n\
#Combined flags for convenience \n\
uint32 SBS_ALL=16777215\n\
uint32 SBS_IMU_ALL=124\n\
uint32 SBS_RANGES_ALL=640\n\
uint32 SBS_ALTITUDE_ALL=384\n\
uint32 SBS_OUTPUT_ALL=253952\n\
\n\
\n\
\n\
"; }
public:
  ROSCPP_DEPRECATED static const std::string __s_getMessageDefinition() { return __s_getMessageDefinition_(); }

  ROSCPP_DEPRECATED const std::string __getMessageDefinition() const { return __s_getMessageDefinition_(); }

  ROSCPP_DEPRECATED virtual uint8_t *serialize(uint8_t *write_ptr, uint32_t seq) const
  {
    ros::serialization::OStream stream(write_ptr, 1000000000);
    return stream.getData();
  }

  ROSCPP_DEPRECATED virtual uint8_t *deserialize(uint8_t *read_ptr)
  {
    ros::serialization::IStream stream(read_ptr, 1000000000);
    return stream.getData();
  }

  ROSCPP_DEPRECATED virtual uint32_t serializationLength() const
  {
    uint32_t size = 0;
    return size;
  }

  typedef boost::shared_ptr< ::coax_msgs::CoaxConstants_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::coax_msgs::CoaxConstants_<ContainerAllocator>  const> ConstPtr;
}; // struct CoaxConstants
typedef  ::coax_msgs::CoaxConstants_<std::allocator<void> > CoaxConstants;

typedef boost::shared_ptr< ::coax_msgs::CoaxConstants> CoaxConstantsPtr;
typedef boost::shared_ptr< ::coax_msgs::CoaxConstants const> CoaxConstantsConstPtr;


template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const  ::coax_msgs::CoaxConstants_<ContainerAllocator> & v)
{
  ros::message_operations::Printer< ::coax_msgs::CoaxConstants_<ContainerAllocator> >::stream(s, "", v);
  return s;}

} // namespace coax_msgs

namespace ros
{
namespace message_traits
{
template<class ContainerAllocator>
struct MD5Sum< ::coax_msgs::CoaxConstants_<ContainerAllocator> > {
  static const char* value() 
  {
    return "c6f600e6dca743e84638da373a8ff5be";
  }

  static const char* value(const  ::coax_msgs::CoaxConstants_<ContainerAllocator> &) { return value(); } 
  static const uint64_t static_value1 = 0xc6f600e6dca743e8ULL;
  static const uint64_t static_value2 = 0x4638da373a8ff5beULL;
};

template<class ContainerAllocator>
struct DataType< ::coax_msgs::CoaxConstants_<ContainerAllocator> > {
  static const char* value() 
  {
    return "coax_msgs/CoaxConstants";
  }

  static const char* value(const  ::coax_msgs::CoaxConstants_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct Definition< ::coax_msgs::CoaxConstants_<ContainerAllocator> > {
  static const char* value() 
  {
    return "\n\
#No obstacle avoidance \n\
uint8 SB_OA_NONE=0\n\
#Horizontal obstacle avoidance \n\
uint8 SB_OA_HORIZONTAL=1\n\
#Vertical obstacle avoidance \n\
uint8 SB_OA_VERTICAL=2\n\
\n\
#Communication on request only \n\
uint8 SB_COM_ONREQUEST=0\n\
#Continuous communication \n\
uint8 SB_COM_CONTINUOUS=1\n\
\n\
#No control \n\
uint16 SB_CTRL_NONE=0\n\
#Position control \n\
uint16 SB_CTRL_POS=1\n\
#Relative set point control (wrt range for instance) \n\
uint16 SB_CTRL_REL=2\n\
#Velocity control \n\
uint16 SB_CTRL_VEL=3\n\
#Acceleration/Force control, currently only used for thrust \n\
uint16 SB_CTRL_FORCE=4\n\
#Manual control \n\
uint16 SB_CTRL_MANUAL=8\n\
\n\
#Step velocity profile for servos in raw mode \n\
uint8 SB_RAWPROFILE_STEP=0\n\
#Ramp velocity profile for servos in raw mode \n\
uint8 SB_RAWPROFILE_RAMP=1\n\
\n\
#Navigation mode: STOP \n\
uint8 SB_NAV_STOP=0\n\
#Navigation mode: IDLE \n\
uint8 SB_NAV_IDLE=1\n\
#Navigation mode: TAKEOFF \n\
uint8 SB_NAV_TAKEOFF=2\n\
#Navigation mode: LAND \n\
uint8 SB_NAV_LAND=3\n\
#Navigation mode: HOVER \n\
uint8 SB_NAV_HOVER=4\n\
#Navigation mode: CTRLLED \n\
uint8 SB_NAV_CTRLLED=5\n\
#Navigation mode: SINK \n\
uint8 SB_NAV_SINK=6\n\
#Navigation mode: RAW \n\
uint8 SB_NAV_RAW=7\n\
#Navigation mode: MANUAL (unused) \n\
uint8 SB_NAV_MANUAL=8\n\
\n\
#Error code in acknowledgement message: no error \n\
uint8 SB_REPLY_OK=   00\n\
#Error code in acknowledgement message: invalid navigation mode \n\
uint8 SB_REPLY_INVALID_NAVMODE=253\n\
#Error code in acknowledgement message: unknown message id or request \n\
uint8 SB_REPLY_UNKNOWN=254\n\
#Error code in acknowledgement message: some error \n\
uint8 SB_REPLY_ERROR=255\n\
#Error code in acknowledgement message: could not decode message \n\
uint8 SB_REPLY_DECODE_FAILURE=252\n\
#Error code in acknowledgement message: request not accepted because system\n\
#  is busy with another connection\n\
uint8 SB_REPLY_BUSY=251\n\
#Error code in acknowledgement message: too early to do this request \n\
uint8 SB_REPLY_TOO_EARLY=250\n\
\n\
#Identification of the range measurement \n\
uint32 SB_RANGE_FRONT=0\n\
uint32 SB_RANGE_LEFT=1\n\
uint32 SB_RANGE_RIGHT=2\n\
uint32 SB_RANGE_BACK=3\n\
\n\
#Id of trim modes \n\
uint32 SB_TRIM_FROM_RC=0\n\
uint32 SB_TRIM_SOFTWARE=1\n\
\n\
#If for RC channels \n\
uint32 SB_RC_THROTTLE=0\n\
uint32 SB_RC_THROTTLE_TRIM=1\n\
uint32 SB_RC_YAW=2\n\
uint32 SB_RC_YAW_TRIM=3\n\
uint32 SB_RC_ROLL=4\n\
uint32 SB_RC_ROLL_TRIM=5\n\
uint32 SB_RC_PITCH=6\n\
uint32 SB_RC_PITCH_TRIM=7\n\
\n\
int32 DEBUG_CHANNEL_NONE=-1\n\
int32 DEBUG_CHANNEL_GUMSTIX=0\n\
int32 DEBUG_CHANNEL_BLUETOOTH=1\n\
\n\
#System mode (nav, comm, ...) \n\
uint32 SBS_MODES=1\n\
#System timestamp \n\
uint32 SBS_TIMESTAMP=2\n\
#Roll, pitch, yaw from IMU \n\
uint32 SBS_RPY=4\n\
#Roll, pitch, yaw rate from IMU \n\
uint32 SBS_GYRO=8\n\
#Acceleration from IMU \n\
uint32 SBS_ACCEL=16\n\
#Magnetic field vector from IMU \n\
uint32 SBS_MAGNETO=32\n\
#Temperature from IMU \n\
uint32 SBS_IMUTEMP=64\n\
#Range to the floor, and filtered altitude \n\
uint32 SBS_ALTITUDE=128\n\
#Altitude from pressure sensor \n\
uint32 SBS_PRESSURE=256\n\
#Horizontal ranges to obstacles \n\
uint32 SBS_HRANGES=512\n\
#Distance to closest object \n\
uint32 SBS_XY_REL=1024\n\
#Battery status \n\
uint32 SBS_BATTERY=2048\n\
#Timeout currently used \n\
uint32 SBS_TIMEOUT=4096\n\
#Output of Attitude control \n\
uint32 SBS_O_ATTITUDE=8192\n\
#Output of Altitude control \n\
uint32 SBS_O_ALTITUDE=16384\n\
#Output of TakeOff/Landing control \n\
uint32 SBS_O_TOL=32768\n\
#Output of XY control \n\
uint32 SBS_O_XY=65536\n\
#Output of Obstacle avoidance control \n\
uint32 SBS_O_OAVOID=131072\n\
\n\
#Output of Obstacle avoidance control \n\
uint32 SBS_CHANNELS=262144\n\
\n\
#Combined flags for convenience \n\
uint32 SBS_ALL=16777215\n\
uint32 SBS_IMU_ALL=124\n\
uint32 SBS_RANGES_ALL=640\n\
uint32 SBS_ALTITUDE_ALL=384\n\
uint32 SBS_OUTPUT_ALL=253952\n\
\n\
\n\
\n\
";
  }

  static const char* value(const  ::coax_msgs::CoaxConstants_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator> struct IsFixedSize< ::coax_msgs::CoaxConstants_<ContainerAllocator> > : public TrueType {};
} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

template<class ContainerAllocator> struct Serializer< ::coax_msgs::CoaxConstants_<ContainerAllocator> >
{
  template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
  {
  }

  ROS_DECLARE_ALLINONE_SERIALIZER;
}; // struct CoaxConstants_
} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::coax_msgs::CoaxConstants_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const  ::coax_msgs::CoaxConstants_<ContainerAllocator> & v) 
  {
  }
};


} // namespace message_operations
} // namespace ros

#endif // COAX_MSGS_MESSAGE_COAXCONSTANTS_H

